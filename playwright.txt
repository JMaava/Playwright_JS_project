НАЧАЛО РАБОТЫ
--------------
Установить:
Git
Node.js
VSC

Terminal:
node -v 
v18.14.0
v20.14.0
Обновление:
Окно выполнить (run) = win+R
appwiz.cpl / программы и компоненты / node.js / удалить
https://nodejs.org/en 
Установить v20.14.0

npm -v
9.3.1
npm install -g npm@latest
10.8.0
Понизить версию: npm install -g npm@версия

установка
npm init playwright@latest

запуск
npx playwright test

Дебаг
npx playwright test --debug

Установить dotenv:
npm i dotenv --save-dev --force
В конфиг добавить require('dotenv').config()
Создать файл .env - можно разместить урл, пароли, логины
Добавить файл в гитигнор
И вместо goto('\') указывать goto(process.env.URL)
================================================================================================================
клонирование проекта:
клонировать репозиторий по ссылке в vsc
npm ci
npx playwright install
npx playwright test gearBags.spec.js --ui открыть один файл
=================================================================================================================
ТЕОРИЯ
----------------
В JavaScript, особенно в контексте асинхронных операций, ключевое слово await используется внутри функций, 
помеченных как async. Это позволяет синхронизированно ожидать результата асинхронной операции, такой как вызов функции, 
возвращающей Promise.

Основы использования await:
__Объявление асинхронной функции__:
async function myFunction() {
    // Код функции
}
__Использование await__: Внутри асинхронной функции, await ставится перед вызовом функции, которая возвращает Promise. 
Это заставляет выполнение функции приостановиться до тех пор, пока Promise не будет разрешен или отклонен.

async function myFunction() {
    const result = await someAsyncFunction();
    console.log(result);
}
Здесь someAsyncFunction() должна быть функцией, возвращающей Promise.

Пример использования await с fetch:
async function fetchData() {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
}

fetchData();
В этом примере:

fetch('https://api.example.com/data') возвращает Promise, который разрешается с объектом ответа.
await приостанавливает выполнение функции до тех пор, пока fetch не вернет ответ.
Затем response.json() также возвращает Promise, который разрешается с данными в формате JSON.
await снова приостанавливает выполнение, пока данные не будут преобразованы в объект JavaScript.
Преимущества использования await:
__Читаемость__: Код с await выглядит более синхронным и легче читается, что упрощает понимание потока выполнения.
__Управление ошибками__: Ошибки в Promise можно перехватывать с помощью блока try...catch, что упрощает обработку 
исключений.
Заключение:
await является мощным инструментом для работы с асинхронным кодом в JavaScript, обеспечивая более удобный и понятный 
способ ожидания результатов асинхронных операций.

В JavaScript обещания (promises) используются для обработки асинхронных операций. Обещание представляет собой объект, 
который представляет окончательный результат или ошибку асинхронной операции. Обещание может находиться в одном из трех 
состояний: ожидание (pending), разрешено (fulfilled) или отклонено (rejected).
Вот пример создания обещания в JavaScript:

// Создание нового обещания
let promise = new Promise((resolve, reject) => {
    // Поддельная асинхронная операция, например, загрузка данных с сервера
    setTimeout(() => {
        let data = "Данные успешно загружены!";
        // При успешном выполнении обещания вызываем функцию resolve
        resolve(data);
        
        // При возникновении ошибки вызываем функцию reject
        // reject("Ошибка: Данные не удалось загрузить!");
    }, 2000);
});

// Использование обещания
promise.then((data) => {
    console.log(data);
}).catch((error) => {
    console.error(error);
});
В этом примере мы создали обещание, имитирующее загрузку данных с сервера. После того, как данные будут успешно загружены,
вызывается функция resolve, передавая данные. Затем мы используем метод then для обработки успешного разрешения обещания 
и метод catch для обработки ошибок.
=====================================================================================================================
ПРОБЛЕМЫ И РЕШЕНИЯ
------------------
Если упал - проверять await

Упал из-за timed out (30 s по умолчанию): в файле конфиг установить таймаут:
module.exports = defineConfig({
  testDir: './tests',
  timeout: 60000, (или больше)

Таймаут для асерта (5 s по умолчанию)- туда же:
expect: {timeout: 10 * 1000},

Либо в самом тесте:
test.setTimeout(10*1000);

Может не отмечать чекбокс или радиобатон по 
page.getByRole и .getByLabel 
Пример:
https://demoqa.com/automation-practice-form

тогда использовать page.getByText либо locator

наводилось на рекламу вместо кнопки логина
locator.focus();
locator.click()
///////////////////////////////////////////////
КОНФИГ
----------
запуск тестов через ui без spec:
testMatch: "*.js"

globalTimeout: 
определяет общее время всех тестов; те, которые не успеют пройти будут помечены failed

в use 
если указать
testIdAttribute: 'id',
то в тестах можно использовать нативный локатор
page.getByTestId('')

Разрешение экрана:
viewport: {width:1920, height: 1080},

baseURL:"", тогда в beforeEach - await page.goto("/")

fullyParallel: false - запускается по файлам(напр. 3 файла=3 workers), внутри файла параллельного запуска нет
true - параллельно внутри файла

workers: process.env.CI ? 1:undefined - на CI запустится 1 worker, при ручном запуске фреймворк сам определяет сколько нужно (вместо
undefined можно указать цифру)

добавить разницу несовпадения в пикселях: 
expect: {
    toMatchSnapshot: {maxDiffPixels: 150}
}
========================================================================
package.json

scripts:можно поменять команду для запуска тестов
"test": "npx playwright test"
В консоли: npm test

============================================================
Аннотации:
------------
https://playwright.dev/docs/test-annotations
test.skip
test.fail (PW сообщит, если тест пройдет, т.к. не ожидаемый результат)
test.fixme (пропустится, но не сообщит, если тест корректен)
test.slow(); - таймаут увеличивается в 3 раза. Писать внутри теста!!! Либо в виде условия
test.only - запуск определенного теста

Hooks:
------------
test.beforeAll()
test.beforeEach()
test.afterAll()
test.afterEach()
==================================================================================================
НЮАНСЫ
--------------
Можно использовать частичное совпадение (только с регулярным выражением)
иначе - д.б. полное совпадение:
await expect(page).toHaveTitle('/текст/') либо ('/.*text/')
await expect(page).toHaveURL(/.*intr/);
.toHaveText

полное совпадение, с регулярным не прошел:
expect(await page.title()).toEqual('')

Допустимо не полное совпадение:
expect(page.getByText('You logged into a secure area!'))
.toContainText

На реальных проектах нужно полное совпадение
============================================================
ассерты:
---------
.toBeVisible
.toHaveAttribute
.toBeChecked
.not.toBeChecked()
.toHaveValue('') - проверка введенного в инпут значения, toHaveText работает только для текста между тегами в дом
.toHaveCSS('border-color', 'rgb(220, 53, 69)')
.toHaveText() - даёт возможность сравнивать строки и массивы
expect(локатор).toHaveText(ожидаемый массив)
.toEqual
.toHaveCount
.ToBe
.toHaveScreenshot ('имя файла, если переименован') - всегда падает первый раз, тк делает скриншот. Или если меняешь имя

expect.soft(page....) - не очень хорошая практика, позволяет тесту не падать, если асерт не проходит
====================================================================================================
Нативные локаторы
--------------------
Аргументы для getByRole 
https://playwright.dev/docs/api/class-framelocator#frame-locator-get-by-role


Методы:
page.getByRole('textbox', {name: 'username'}).
page.getByText('You logged into a secure area!')) {exact: true} - для полного совпадения текста
.getByLabel ('текст в теге с лейблом')
Для радио и чекбоксов - .check() - не сработает для отмеченного по умолчанию
Снять - click(), uncheck() 
.getByPlaceholder
locator.selectOption - позволяет выбрать из выпадающего списка без клика 
locator.allInnerText() - выводит и скрытый текст
locator.allTextContents() - не выводит скрытый текст
.setInputFiles('путь к файлу')

Элементы:
.first()
.nth(1) (нумерация как в массивах)
.last()

С массивами:
.filter
list.filter({hasText: 'Home'}).click() - регистр значения не имеет

ЛОКАТОРЫ 
ul.search-dropdown-menu>li>span:nth-child(1)
.rt-tbody [role="row"]:not(.-padRow)


==========================================================================
Принудительный поиск элемента, НЕ РЕКОМЕНДУЕТСЯ
checkbox.check({force: true})

===========================================================================
зачем exact в методе page.getByText('Hello', { exact: true });

В Playwright, `exact` параметр в методе `page.getByText` используется для точного соответствия текста. 
Это означает, что метод будет искать элемент, текст которого точно соответствует переданному аргументу, 
без дополнительных символов или слов до или после него.

Если `exact` установлен в `false` (по умолчанию), метод будет искать элементы, содержащие переданный текст в 
любом месте текста элемента. Например, если вы ищете `'Hello'` с `exact: false`, он найдет элементы с 
текстом `'Hello world'`, `'Goodbye Hello'` и т.д.

Если `exact` установлен в `true`, метод будет искать элементы, текст которых точно равен `'Hello'`. 
В этом случае, он не найдет элементы с текстом `'Hello world'` или `'Goodbye Hello'`.

Таким образом, использование `exact` может быть полезным, когда вам нужно найти конкретный элемент с определенным 
текстом, и вы не хотите, чтобы метод находил элементы, содержащие этот текст в более длинных строках.

=================================================================================================================
методы textContent (для массива?), innerText (для локатора, не массива) 
используются для дебаггинга, в тестах избегать, применять
.toContainText

const text = await page.locator('').textContent();
console.log(text)

=====================================================================================================
Вывести все элементы в массиве в консоли:
const list = page.getByRole('listitem');
console.log(await list.all())
allInnerText() - текст элементов

=====================================================================================================
Заморозка в консоли 
setTimeout ( () =>{debugger}, 3000)

=======================================================================================================
В Playwright, page.getByRole('button', {name: 'submit'}) используется для поиска кнопки на странице, которая имеет 
роль (role) button и имя (name), которое соответствует тексту "submit". Здесь name используется для указания текста, 
который должен быть на кнопке, чтобы Playwright смог её найти.

Вот более подробное объяснение каждого параметра:

role: Этот параметр указывает тип элемента, который вы ищете. В данном случае button указывает, что вы ищете кнопку.

name: Этот параметр используется для фильтрации элементов по их видимому тексту или альтернативному тексту 
(атрибут aria-label или aria-labelledby для элементов, использующих ARIA). В данном случае, name: 'submit' 
означает, что вы ищете кнопку с текстом "submit" на ней.
======================================================================================================
Вывести элементы в консоли по локатору:
$('locator')
============================================================================================
РАБОТА С НОВОЙ ВКЛАДКОЙ
const pageFirstPromise = page.waitForEvent("popup")
нажимаем на элемент, уходим на другую page
const newPage = await pageFirstPromise

expect c newPage
=========================================================================================
ОЖИДАНИЯ

locator.waitFor() - для локатора, по дефолту(пустые скобки) - visible
({state:'attached'}) - появился в доме

page.waitForSelector(locator) - в доке указано менять на waitFor

page.waitForTimeout(6000) - не применять

page.waitForResponse(url)
url - (response=>response.url()==='http...' && response.status()===200)


=============================================================================================
FIXTURES
расширение .js
содержит методы
запускать вручную или через scope













